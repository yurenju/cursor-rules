---
description:
globs:
alwaysApply: false
---

# 規則：從 PRD 產生任務清單

## 目標

指導 AI 助手根據現有的產品需求文件 (PRD) 創建詳細的、逐步的 Markdown 格式任務清單。任務清單應該指導開發者進行 TDD（測試驅動開發）實作。

## 輸出

- **格式：** Markdown (`.md`)
- **位置：** `/tasks/`
- **檔案名稱：** `tasks-[prd-檔案名稱].md`（例如，`tasks-prd-user-profile-editing.md`）

## 流程

1.  **接收 PRD 參考：** 使用者向 AI 指出特定的 PRD 檔案
2.  **分析 PRD：** AI 讀取並分析指定 PRD 的功能需求、使用者故事和其他部分。
3.  **撰寫 Gherkin 驗收條件：** 使用 Cucumber 的 Gherkin 語法撰寫整個 PRD 的高階驗收條件。這些驗收條件將用於後續透過 MCP 直接觀察產出，確保實作確實達到目的。應包含主要的 Feature、Scenario 和 Given-When-Then 步驟，涵蓋核心功能和關鍵使用者流程。
4.  **階段 1：產生父任務：** 根據 PRD 分析和 Gherkin 驗收條件，創建檔案並產生遵循 TDD 方法論實現功能所需的主要高層級任務。使用您的判斷決定使用多少個高層級任務。可能大約是 5 個。以指定格式向使用者呈現這些任務（尚未包含子任務）。告知使用者：「我已根據 PRD 使用 TDD 方法論產生了高層級任務。準備產生詳細的子任務嗎？回應『Go』以繼續。」
5.  **等待確認：** 暫停並等待使用者回應「Go」。
6.  **階段 2：產生子任務：** 一旦使用者確認，將每個父任務分解為更小的、可操作的子任務，遵循 TDD 開發流程。確保子任務邏輯性地遵循 5 階段 TDD 流程並涵蓋 PRD 暗示的實作細節。
7.  **識別相關檔案：** 根據任務和 PRD，識別需要創建或修改的潛在檔案。在 `相關檔案` 部分列出這些檔案，包括對應的測試檔案。
8.  **產生最終輸出：** 將父任務、子任務、相關檔案、驗收標準、PRD 參考和註釋結合到最終的 Markdown 結構中。
9.  **儲存任務清單：** 將產生的文件儲存在 `/tasks/` 目錄中，檔案名稱為 `tasks-[prd-檔案名稱].md`，其中 `[prd-檔案名稱]` 符合輸入 PRD 檔案的基本名稱。

## TDD 開發流程

產生的任務應該遵循這個細緻的、基於類別/檔案的 TDD 方法論：

### 每個類別/檔案的 TDD 循環

每個類別或檔案在移動到下一個之前應該經歷完整的 TDD 循環：

1. **為單一類別/檔案定義結構**

   - 為一個特定的類別/檔案定義基本結構（可以是 TypeScript 介面、空類別或存根函數）
   - 對於類別：創建帶有拋出「未實作」錯誤的方法簽名
   - 對於函數：創建帶有拋出「未實作」錯誤的參數的函數簽名
   - 對於 TypeScript 介面：僅在多個類別需要實作相同合約時定義
   - 僅為此組件建立基本結構並確定函數簽名和返回類型

2. **為此類別/檔案撰寫測試結構**

   - 僅為此特定類別/檔案撰寫 `describe` 和 `it` 陳述宣告
   - 不要在 `it` 區塊內實作任何測試邏輯或斷言
   - **專注於核心功能和主要錯誤場景** - 優先考慮基本測試覆蓋而非全面的邊緣情況測試。舉例來說，一個函式、hook 提供的 function，包含核心功能與主要錯誤加起來，最好不要超過五個測試項目
   - 保持 `it` 區塊主體為空 - 這允許使用者在實作之前確認測試方法和範圍
   - 僅專注於當前正在開發的組件
   - 目的是在撰寫實際測試程式碼之前獲得使用者對將測試哪些方面的批准

3. **實作測試邏輯（紅色階段）**

   - 為此類別/檔案撰寫帶有斷言的完整測試程式碼
   - **測試應該期望正確的功能行為和返回值，而不是僅僅驗證「未實作」錯誤的拋出**
   - 測試應該驗證實際功能（返回值、副作用、適當的錯誤類型）
   - 執行測試以確保所有測試都失敗，因為功能尚未實作
   - 驗證測試因正確原因失敗（缺少實作，而非語法錯誤）
   - 如需要，根據測試回饋調整介面設計

4. **實作功能邏輯（綠色階段）**

   - 從最小實作開始使第一個測試通過
   - 逐漸實作更多功能使額外測試通過
   - 迭代優化實作直到所有測試通過
   - 在移動到下一個組件之前完成此組件

5. **移動到下一個類別/檔案**
   - 為下一個組件重複整個循環
   - 逐步建構，一次一個組件

### 實作順序

任務應該按依賴順序組織，首先實作基礎組件：

- 實用函數和輔助程式
- 核心服務類別
- API 整合類別
- React hooks
- UI 組件和示範頁面

### 關鍵原則

- **一次一個組件**：在繼續之前為每個類別/檔案完成完整的 TDD 循環
- **開發者確認**：在開始實作之前，在每個組件的測試結構之後獲得批准
- **增量建構**：每個組件建立在先前完成、測試過的組件之上
- **即時回饋**：個別測試和驗證每個組件
- **紅色階段驗證**：所有測試最初必須失敗以確保測試有效性
- **綠色階段進展**：逐漸實作功能使測試一個接一個通過

## 輸出格式

產生的任務清單 _必須_ 遵循此結構：

```markdown
## PRD 參考

**來源文件**：[連結到此任務清單所基於的原始 PRD 檔案]

此任務清單實作上述 PRD 中指定的功能。請參考 PRD 以獲得詳細的上下文、需求和使用者故事。

## 根本問題

[基於 PRD 分析的所解決核心問題的簡要描述]

## Gherkin 驗收條件

使用 Cucumber 的 Gherkin 語法定義的高階驗收條件，用於透過 MCP 直接觀察和驗證實作成果：

\`\`\`gherkin
Feature: [功能名稱]
As a [使用者角色]
I want to [想要做的事]
So that [期望的結果]

Scenario: [場景名稱]
Given [前置條件]
When [執行動作]
Then [預期結果]
And [額外驗證]

Scenario: [另一個場景名稱]
Given [前置條件]
When [執行動作]
Then [預期結果]
\`\`\`

## 相關檔案

- `path/to/potential/file1.ts` - 為什麼此檔案相關的簡要描述（例如，包含此功能的主要服務類別）。
- `path/to/potential/file1.test.ts` - `file1.ts` 的單元測試（與實作共同放置）。
- `path/to/another/file.tsx` - 簡要描述（例如，資料提交的 API 路由處理程式）。
- `path/to/another/file.test.tsx` - `file.tsx` 的單元測試（與實作共同放置）。
- `lib/utils/helpers.ts` - 簡要描述（例如，計算所需的實用函數）。
- `lib/utils/helpers.test.ts` - `helpers.ts` 的單元測試（與實作共同放置）。

### TDD 實作規則

**關鍵**：每個組件必須逐步遵循 TDD 循環，除非使用者明確指示，否則不允許跳過：

1. **結構定義階段**：

   - 根據需要創建空類別、函數存根或介面
   - 對於函數：創建帶有拋出「未實作」錯誤的參數的函數簽名
   - 對於類別：創建帶有拋出「未實作」錯誤的方法簽名的空類別
   - 僅在多個類別需要實作相同合約時定義 TypeScript 介面

2. **測試結構階段**：

   - **僅撰寫沒有內部測試邏輯的 `describe` 和 `it` 宣告**
   - **僅專注於核心功能和關鍵錯誤場景** - 目標是基本測試覆蓋，而非詳盡的邊緣情況
   - 保持所有 `it` 區塊完全為空 - 沒有斷言或測試程式碼
   - 目的：允許開發者在實作之前確認測試方法和範圍

3. **測試邏輯階段（紅色階段）**：

   - 用完整的測試程式碼和斷言填充空的 `it` 區塊
   - **測試必須期望實際功能/行為，而不是「未實作」錯誤**
   - 測試應該驗證真實的返回值、副作用和適當的錯誤類型
   - 執行測試確認**所有測試都失敗**，因為實作缺失（這是必需的）
   - 驗證測試因缺少實作而失敗，而非語法錯誤

4. **功能實作階段（綠色階段）**：
   - 從最小實作開始使第一個測試通過
   - 逐漸實作更多功能使額外測試通過
   - 在移動到下一個組件之前完成當前組件

### 註釋

- 測試檔案應該與其實作檔案共同放置在同一目錄中
- 測試檔案使用 `.test.ts` 或 `.test.tsx` 後綴
- 如需要，整合測試可以放在單獨的 `tests/` 目錄中，使用 `.integration.test.ts` 後綴
- 使用 `npx jest [可選/路徑/到/測試/檔案]` 執行測試。不帶路徑執行會執行 Jest 配置找到的所有測試。
- **嚴格遵循 TDD 方法論**：每個子任務應該一次完成一個，在繼續下一個子任務之前需要開發者確認。
- 在有助於視覺化系統互動和資料流程時使用 Mermaid 圖表。

## 任務

請一次完成一個組件，在繼續下一個組件之前為每個類別/檔案遵循完整的 TDD 循環。

- [ ] 1.0 **[組件名稱 1] - 完整 TDD 循環**

  - [ ] 1.1 為 [組件名稱 1] 定義結構（介面/類別/函數存根）
  - [ ] 1.2 為 [組件名稱 1] 撰寫測試結構（`describe` 和 `it` 陳述）
  - [ ] 1.3 為 [組件名稱 1] 實作測試邏輯並執行測試（紅色階段）
  - [ ] 1.4 為 [組件名稱 1] 實作功能邏輯（綠色階段）

- [ ] 2.0 **[組件名稱 2] - 完整 TDD 循環**

  - [ ] 2.1 為 [組件名稱 2] 定義結構（介面/類別/函數存根）
  - [ ] 2.2 為 [組件名稱 2] 撰寫測試結構（`describe` 和 `it` 陳述）
  - [ ] 2.3 為 [組件名稱 2] 實作測試邏輯並執行測試（紅色階段）
  - [ ] 2.4 為 [組件名稱 2] 實作功能邏輯（綠色階段）

- [ ] 3.0 **[組件名稱 3] - 完整 TDD 循環**

  - [ ] 3.1 為 [組件名稱 3] 定義結構（介面/類別/函數存根）
  - [ ] 3.2 為 [組件名稱 3] 撰寫測試結構（`describe` 和 `it` 陳述）
  - [ ] 3.3 為 [組件名稱 3] 實作測試邏輯並執行測試（紅色階段）
  - [ ] 3.4 為 [組件名稱 3] 實作功能邏輯（綠色階段）

- [ ] [剩餘組件繼續此模式...]

- [ ] **最終驗收**：閱讀 Gherkin 語法的驗收條件後，直接透過 MCP 或指令來確認是否可通過驗收

### 組件實作順序

組件應該按依賴順序實作：

1. **實用函數**：輔助函數和計算
2. **核心服務**：業務邏輯和資料處理
3. **API 整合**：外部服務通訊
4. **React Hooks**：狀態管理和 UI 邏輯
5. **UI 組件**：示範頁面和使用者介面
```

## 互動模式

流程明確要求：

1. **在產生父任務後暫停**，在繼續產生詳細子任務之前獲得使用者確認（「Go」）
2. **逐任務完成**，遵循 TDD 方法論，在每個主要階段之間需要開發者確認
3. **測試優先方法**，確保在實作開始之前審查測試結構

這確保高層級計劃符合使用者期望，並在整個開發過程中遵循適當的 TDD 實踐。

## 目標受眾

假設任務清單的主要讀者是將使用 TDD 方法論實作功能的 **初級開發者**。任務應該指導他們通過適當的測試驅動開發實踐，同時建構 PRD 中指定的功能。
